\chapter{Projekt i implementacja}
W tym rozdziale przedstawiono szczegóły implementacji systemu. 
Poszczególne zagadnienia oraz aplikacje wchodzące w jego skład
zostały opisane w oddzielnych sekcjach tego rozdziału.

\section{Komponenty systemu i komunikacja}
Komunikacja między komponentami aplikacji odbywa się z wykorzystaniem protokołu 
HTTP (ang. \textit{Hypertext Transfer Protocol}).
Jest to jedna z technologii wykorzystywana w modelu TCP/IP 
nazywanego również protokołem Internetowym (ang. \textit{Internet Protocol}).
Jest protokołem bezstanowym \cite{http:rfc9110} służącym do przesyłania
informacji w postaci hipertekstowej i jest podstawowym rozwiązaniem
stosowanym w sieci WWW (ang. \textit{World Wide Web}), będąca systemem 
służącym do udostępniania informacji poprzez sieć Internet
z wykorzystaniem adresów URI (ang. \textit{Uniform Resource Identifier}) \cite{Jacobs:04:AWW}.

Dodatkowo wykorzystany został protokół kanałów komunikacyjnych WebSocket.
Pracują one w trybie pełnego dupleksu, co zezwala na obustronną komunikację
klienta z serwerem oraz serwera z klientem. Największą jego zaletą jest
możliwość wykorzystania protokołu HTTP w celu ustanowienia połączenia 
oraz wykorzystanie tych samych portów 80 oraz 443.
Aby ustanowić połączenie klient powinien wysłać odpowiedni
nagłówek nazywany HTTP Upgrade, na który serwer odpowiada z informacją o zmianie protokołu.
Następnie połączenie zmienia protokół z HTTP do binarnej transmisji bezpośrednio wykorzystującej TCP.
W tym momencie obie strony z jego wykorzystaniem mogą odczytywać oraz wysyłać wiadomości
pomiędzy sobą.

Protokoły wykorzystane w celu komunikacji przedstawione zostały na Rys. \ref{diagram:comms}.
\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{comms_diagram}
  \caption{Protokoły wykorzystane w komunikacji między komponentami}
  \label{diagram:comms}
\end{figure}

\section{Aplikacja serwerowa}
Aplikacja serwerowa została zaimplementowana jako centralny komponent systemu.
Zajmuje się zapisem odczytów w bazie danych, przetwarzaniem zapytań
pozostałych warstw, klienckiej oraz urządzeń pomiarowych,
poprzez wykorzystanie różnych metod HTTP.
Metoda POST zajmuje używana jest w nim do przekazywania danych
dla serwera w procesach takich jak tworzenie konta użytkownika,
wysyłanie nowego odczytu czy uwierzytelnianie.
Aplikacja następnie przetwarza te zapytanie oraz w odpowiedni 
sposób na nie reaguje, np. zapisując je na stałe do bazy danych 
lub wysyłając notyfikację użytkownikowi, po czym odpowiada
odpowiednim statusem klientowi.
Kolejną szeroko zastosowaną metodą jest GET. Służy ona do pobierania
zasobów z serwera. Klient wykorzystuje odpowiedni adres URI z
podstawowymi danymi lub bez, pod który wykonuje zapytanie, a
następnie serwer zwraca odpowiedź z zażądanymi informacjami.
Metodami służącymi do modyfikacji zasobów są PUT oraz DELETE.
Pierwsza z nich wykorzystywana jest do zmieniania istniejących
już zasobów lub tworzenia ich na nowo. DELETE natomiast służy
do usuwania zasobów.

\subsection{Architektura aplikacji}
Jako szkielet logiki aplikacji został wykorzystany wzorzec CQRS 
(ang. \textit{Command Query Responsibility Separation}).
W tym modelu akcje dzielą się na dwa typy komendy oraz zapytania \cite{fowler:cqrs}.
Komendy służą do interakcji z systemem, np. tworzenie użytkowników.
Mogą zawierać dodatkową logikę jak weryfikacja danych wejściowych 
czy sprawdzanie duplikatów.
Zapytania spełniają funkcję dostępu do danych. Pobierane oraz
filtrowane są w nich informacje z systemu i w razie potrzeby
odpowiednio transformowane.
Dzięki stosowaniu się do zasad tej metodyki aplikacja wolna
jest od efektów ubocznych i tworzenie zapytań nie zmienia
wartości systemu. Pozwala również na uproszczenie logiki
aplikacji ze względu na podział na proste moduły oraz bardzo
dobrą skalowalność z rozwiązaniami wielowątkowymi.
W implementacji tej metodyki wykorzystano bibliotekę MediatR.
Udostępnia ona bardzo łatwy w użyciu wzorzec mediatora.
Pozwala on na redukcję zależności między komponentami poprzez
zastosowanie centralnego obiektu zajmującego się komunikacją między nimi\cite{freeman2004head}.
W tym przypadku komponentami są komendy oraz zapytania i do ich realizacji
została wykorzystana dynamiczna implementacja centralnego
mediatora z biblioteki MediatR. Oddziela to dane od implementacji
zachowań i pozwala na ich niezależną modyfikacje.

Klasy danych wywodzą się z głównej klasy abstrakcyjnej \textbf{BaseModel}.
Zawiera ona podstawowe dane o obiekcie tj. id, data stworzenia oraz data modyfikacji.
Poza tym implementuje podstawowe funkcje do porównywania z innymi obiektami oraz
tworzeniu kodu hash. Bezpośrednio z niej dziedziczy klasa \textbf{Reading} odpowiadająca
za przechowywanie szczegółów o odczytach. Zawiera informacje o typie odczytu, jego wartości,
dacie i czasie kiedy dany odczyt został pobrany oraz jego jednosce.
Dodatkową klasą abstrakcyjną, która sama dziedziczy po klasie \textbf{BaseModel} i
jest wykorzystywana przez inne klasy domeny jest \textbf{BaseUser}. Jest to bazowa klasa
użytkownika i zawiera informacje takie jak nazwa użytkownika, zakodowane hasło, stan aktywności
oraz rola. Z tej klasy dziedziczą klasy \textbf{Device} oraz \textbf{User}. Pierwsza z nich 
zawiera dodatkowe informacje o urządzeniach pomiarowych, a druga o użytkownikach lub administratorach 
w zależności od ich roli.
Oddzielnym modelem jest klasa służąca do przechowywania konfiguracji. Składa się ona z dwóch pól -
klucza oraz wartości. Wartość nie ma z góry określonego typu i może być dowolnym obiektem, który
jest możliwy do zapisu w postaci JSON.
Zależności między klasami zostały przedstawione na Rys. \ref{diagram:domain}.
\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{domain}
  \caption{Diagram klas modeli danych}
  \label{diagram:domain}
\end{figure}

Serwis notyfikacji został zaimplementowany z użyciem wzorca dekorator.
Jest to wzorzec projektowy pozwalający na dynamiczne dodawanie nowego
zachowania obiektowi bez modyfikacji innych obiektów tej samej klasy
\cite{freeman2004head}. Tym samym ułatwia on dostosowanie się do zasady
pojedynczej odpowiedzialności (ang. \textit{Single responsibility principle})
poprzez wydzielenie logiki na klasy zajmujące się tylko jednym zadaniem.
Jego wykorzystanie oznacza również zastosowanie zasady otwarte-zamknięte, w
której części systemu powinny być otwarte na rozszerzanie, ale zamknięte
na modyfikacje \cite{meyer1988object}. Jest to możliwe, gdyż dekorator pozwala
na dodanie nowych funkcjonalności obiektowi bez jego ponownego tworzenia.
Z jego wykorzystaniem użytkownik jest w stanie skonfigurować system notyfikacji,
aby ten wysyłał powiadomienia do różnych celów takich jak poczta elektroniczna
czy powiadomienia z wykorzystaniem połączeń WebSocket. Wzorzec dekorator został
przedstawiony za pomocą diagramu klas na Rys. \ref{pattern:decorator}.
\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{decorator}
  \caption{Diagram klas wzorca dekorator}
  \label{pattern:decorator}
\end{figure}

Pozostałe aplikacje w systemie mogą komunikować się z serwerem poprzez wykorzystanie
zapytań do odpowiednich kontrolerów. Zależnie od punktu końcowego muszą one
przesłać odpowiednie informacje w postaci ciała, ciągu lub argumentu pozycyjnego
zapytania. Aplikacja zawiera kontrolery zajmujące się odpowiednim im zadaniom:
\begin{itemize}
  \item zapis oraz odczyt parametrów środowiska,
  \item autoryzacja oraz tworzenie kont,
  \item konfiguracja oraz pobieranie konfiguracji systemu,
  \item pobieranie szczegółowych danych o urządzeniach oraz ich statusie,
  \item rozpoczynanie połączenia z WebSocket'ami.
\end{itemize}
W celu ułatwienia obsługi każdy z kontrolerów znajduje się na ścieżce URI odpowiadającej
jego nazwie, np. kontroler odczytów znajduje się pod ścieżką /api/Reading.
Dodatkowo serwer udostępnia dwa połączenia WebSocket - notyfikacyjne oraz
dla urządzeń. Pierwsze z gniazd wykorzystywane jest do przesyłania
powiadomień do pozostałych aplikacji. Autoryzowani użytkownicy mogą
się z nim połączyć, aby uzyskać dostęp do wiadomości o niespodziewanych
wartościach odczytów parametrów środowiska. Gniazdo przeznaczone dla
urządzeń służy natomiast do synchronizacji konfiguracji oraz
udostępnienia statusu. Wszystkie połączenia powinny co 30 sekund
wysyłać wiadomość z zawartością "ping", aby zapewnić stałość połączenia.
W przeciwnym wypadku serwer uznaje połączenie za przerwane i zamyka je.
Wykorzystywane są one również do udostępniania notyfikacji oraz
synchronizacji konfiguracji z pozostałymi urządzeniami.
Diagram klas zawierający informacje o kontrolerach został przedstawiony na
Rys. \ref{diagram:controller_class}.
\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{controller_class}
  \caption{Diagram klas kontrolerów}
  \label{diagram:controller_class}
\end{figure}

Dostęp do danych odbywa się poprzez wykorzystanie oficjalnego sterownik
baz danych MongoDB dla środowiska .NET. Jego wykorzystanie 
umożliwiło na prostą interakcję między aplikacją oraz bazą
danych. Zamiast ręcznie dokonywać połączenia oraz przesyłać
komendy możliwa jest interakcja poprzez udostępniony interfejs.
Umożliwia on na wykorzystanie zaawansowanych technik takich jak
LINQ co znacznie ułatwiło tworzenie zapytań. Technologia ta
pomaga również w mapowaniu obiektów baz danych na klasy języka C\#.
W większości przypadków takie zależności tworzone są automatycznie,
jedynie w przypadku nadmiarowych lub braku wymaganych danych potrzebna
jest interakcja programisty. Przykładem z implementacji jest wymaganie
mapowania klas dziedziczących.
\begin{lstlisting}[language={[Sharp]C},caption={Tworzenie mapy klas dla typów użytkownika},label={mongodb:user},captionpos=b]
BsonClassMap.RegisterClassMap<BaseUser>(cm =>
{
    cm.AutoMap();
    cm.AddKnownType(typeof(Device));
    cm.AddKnownType(typeof(User));
});
\end{lstlisting}
W listingu \ref{mongodb:user} tworzona jest mapa automatyczna dla klasy BaseUser - podstawowej
użytkownika, a następnie wiązane są z nią dwa typy pochodne - Device, czyli urządzenie
oraz User, czyli użytkownik. Pozwala to na dostęp do obu typów użytkownika
z jednego kontekstu bazy danych.


\subsection{Implementacja wybranych funkcjonalności}

Wykorzystanie technologii ASP.NET ułatwiło znacznie wykonanie systemu autoryzacji. 
Pakiet Microsoft.AspNetCore.Authentication zawiera często wykorzystywane metody
uwierzytelniania użytkowników. W implementacji aplikacji użyto metody tokenów JWT
(ang. \textit{JSON Web Token}). Jest to krótka, zakodowana w systemie Base64, 
reprezentacja uprawnień użytkownika używana w środowiskach z ograniczoną przestrzenią 
takich jak HTTP\cite{jwt:rfc7519}. Oprócz tego zawiera informacje o
czasie jego przedawnienia, audiencji oraz emitenta. Dzięki temu
może zostać wykorzystany w systemach pojedynczego logowania
SSO (ang. \textit{Single sign-on}) i wykorzystywany poprzez wiele aplikacji.
W implementacji został wykorzystany algorytm HmacSha256 do cyfrowego
podpisywania ważności tokenu. Sterowanie innymi parametrami takimi jak czas
przedawnienia, audiencja orz emitent odbywa się za pomocą edytowalnych
plików konfiguracyjnych.
\begin{lstlisting}[language={[Sharp]C},caption={Tworzenie tokenu JWT},label={jwt:create},captionpos=b]
var token = new JwtSecurityToken(
  config["Issuer"],
  config["Audience"],
  claims,
  expires: DateTime.Now.Add(expiration),
  signingCredentials: new SigningCredentials(
    new SymmetricSecurityKey(Encoding.UTF8.GetBytes(config["SecretKey"])),
  SecurityAlgorithms.HmacSha256));
\end{lstlisting} 
Następnie w konfiguracji aplikacji umieszczono odpowiednie opcje walidacji tokenów.
Ich konfiguracja została zaprezentowana na listingu \ref{jwt:opts}.
\begin{lstlisting}[language={[Sharp]C},caption={Opcje walidacji JWT},label={jwt:opts},captionpos=b]
opt.TokenValidationParameters = new TokenValidationParameters
{
  ValidateIssuer = true,
  ValidIssuer = config.GetValue<string>("Issuer"),
  ValidateAudience = true,
  ValidAudience = config.GetValue<string>("Audience"),
  ValidateLifetime = true,
  ClockSkew = TimeSpan.FromSeconds(0),
  ValidateIssuerSigningKey = true,
  IssuerSigningKey = new SymmetricSecurityKey(
    Encoding.UTF8.GetBytes(config.GetValue<string>("SecretKey"))
  )
};
\end{lstlisting} 
Ustawione zostały opcje takie jak walidacja emitenta, audiencji, czasu życia oraz
klucza, którym został podpisany token.
Hasła użytkowników przechowywane są po wcześniejszym zakodowaniu algorytmem SHA256
z dodatkowymi informacjami nazywanymi solą. Są to losowe dane, które pozwalają na
dodatkowe zabezpieczenie kluczy przed wykryciem duplikatów lub ataków słownikowych
\cite{anderson2020security}.
Aby odpowiednio przejść proces uwierzytelniania użytkownik musi przesłać
swoją nazwę użytkownika oraz hasło zapytaniem z metodą POST pod odpowiedni adres
URI. Następnie jeżeli dane są prawidłowe w odpowiedzi otrzyma on wartość
token, która następnie może wykorzystać do dostępu do zablokowanych anonimowym
użytkownikom zasobów, takich jak tworzenie nowych odczytów. Wartość
ta musi zostać przesłana w nagłówku Authorization.
Użytkownicy dzielą się na różne role: administrator, użytkownik oraz urządzenie.
Administrator ma dostęp do wszystkich opcji aplikacji - konfiguracji, zarządzania odczytami
oraz użytkownikami, przeglądanie zasobów. Urządzenie może zarządzać jedynie swoimi
danymi, a zwykły użytkownik nie ma dostępu do edycji zasobów i może jedynie przeglądać
wartości.

Reguły sterujące logiką wysyłania powiadomień zbudowane zostały przy użyciu systemu
ekspresji środowiska .NET. Dzięki temu użytkownik może w rozbudowany sposób
tworzyć logikę określającą przy jakich warunkach powinna być wysłana dana wiadomość.
Dzięki temu, że są one kompilowane podczas wykonywania programu mogą przyjąć dowolną
formę, więc nie ograniczają użytkownika w ich tworzeniu oraz modyfikacji.
\begin{lstlisting}[language={[Sharp]C},caption={Kompilacja formy tekstowej ekspresji},label={valid:comp},captionpos=b]
try
{
    var options = ScriptOptions.Default.AddReferences(typeof(Reading).Assembly);
    var expression = await CSharpScript.EvaluateAsync<Expression<Func<Reading, bool>>>(
        rule.Condition,
        options
    );
    newRules.Add(
        new ValidationRule
        {
            Condition = expression,
            Message = rule.Message,
            Severity = rule.Severity
        }
    );
}
catch (CompilationErrorException e)
{
    throw new InvalidRuleException(e.Message.Split(": ").Last());
}
\end{lstlisting}
Na listingu \ref{valid:comp} przedstawiono kod odpowiedzialny za kompilację ekspresji podczas działania
aplikacji. Wykorzystana została do tego biblioteka Microsoft.CodeAnalysis. Ekspresja kompilowana jest
jako funkcja przyjmująca na wejściu odczyt oraz zwracająca wartość bool. W przypadku nieodpowiedniej składni
łapany jest błąd kompilacji a następnie zwracana jest on nim informacja użytkownikowi.
Serializacja oraz de-serializacja ekspresji została wykonana przy użyciu biblioteki
Remote.Linq pozwalająca na ich zapis oraz odczyt do różnych formatów takich jak
JSON czy XML, które następnie przechowywane są w bazie danych. Aby wykorzystać ją
z bazą danych MongoDB należało zaimplementować dodatkowy serializator, którego implementacja
została przedstawiona na listingu \ref{expr:serialization}.
\begin{lstlisting}[language={[Sharp]C},caption={Serializacja ekspresji},label={expr:serialization},captionpos=b]
public Expression<TDelegate> Deserialize(
    BsonDeserializationContext context,
    BsonDeserializationArgs args
)
{
    var bsonReader = context.Reader;
    if (bsonReader.CurrentBsonType == BsonType.Null)
    {
        bsonReader.ReadNull();
        return null;
    }
    var binaryData = bsonReader.ReadBinaryData();
    var remote = JsonSerializer.Deserialize<Remote.Linq.Expressions.LambdaExpression>(
        binaryData.Bytes,
        jsonSerializerOptions
    );
    return (Expression<TDelegate>)remote.ToLinqExpression();
}
public void Serialize(
    BsonSerializationContext context,
    BsonSerializationArgs args,
    Expression<TDelegate> value
)
{
    var bsonWriter = context.Writer;
    if (value is null)
    {
        bsonWriter.WriteNull();
        return;
    }
    var remote = value.ToRemoteLinqExpression();
    bsonWriter.WriteBinaryData(
        JsonSerializer.SerializeToUtf8Bytes(remote, jsonSerializerOptions)
    );
}
\end{lstlisting}

Aby ułatwić implementację pozostałych aplikacji oraz w celu zapewnienia dokumentacji
wykorzystano bibliotekę Swashbuckle. Dostarcza ona składniki takie jak 
\begin{itemize}
  \item generator schematów OpenAPI, które mogą być następnie wykorzystane do generowania klientów
wykorzystujących dane API,
  \item generator dokumentacji bazujący na komentarzach znajdujących się w kodzie aplikacji,
  \item interfejs swagger-ui umożliwiający na przeglądanie zasobów z poziomu przeglądarki internetowej.
\end{itemize}
Interfejs swagger-ui przedstawiono na Rys. \ref{swagger:interface}.
\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{swagger}
  \caption{Intefejs swagger-ui}
  \label{swagger:interface}
\end{figure}
Kod wygenerowany na podstawie schematów wygenerowanych przez tą bibliotekę został następnie
wykorzystany zarówno w aplikacji klienckiej jak i urządzeniach pomiarowych.
Wykorzystano do tego oprogramowanie openapi-generator wspierające wiele języków
programowania oraz różnych bibliotek służących do komunikacji z użyciem protokołu HTTP.
Jest ono w stanie, na podstawie schematów OpenAPI, utworzyć klienta wraz z odpowiednimi
modelami jak również trzon aplikacji serwerowej oraz dokumentację. Pozwala również
na modyfikowanie wzorów generowanego kodu poprzez pliku mustache, za pomocą których
definiowana jest struktura wygenerowanych plików.

\section{Aplikacja kliencka}
Aplikacja kliencka powstała w celu ułatwienia dostępu do zasobów systemu.
Umożliwia ona na przedstawienie danych związanych z odczytami jak i konfigurację
aplikacji wykorzystując przyjazny użytkownikowi interfejs. W tym celu komunikuje
się ona z serwerem i na podstawie otrzymanych danych przedstawia je w formacie
czytelnym dla człowieka. 

\subsection{Architektura aplikacji}
Aplikacja kliencka dzieli się na komponenty oraz widoki z nich korzystające.
Do widoków należą podstrony tj.:
\begin{itemize}
  \item strona główna - zawiera listę odczytów w przypadku zalogowanego użytkownika
    lub przekierowanie do logowania w przeciwnym przypadku,
  \item strona z logowaniem - zawiera prosty formularz logowania,
  \item strona z ustawieniami - zawiera konfigurację aplikacji,
  \item strona z urządzeniami - zawiera listę urządzeń wraz z ich stanem połączenia,
  \item strona z użytkownikami - zawiera listę użytkowników oraz umożliwia na ich usunięcie.
\end{itemize}
Komponentami, które wykorzystywane są na każdej ze stron jest \textbf{UserContextProvider}
oraz \textbf{Nav}.
Zadaniem pierwszego z nich jest dostarczenie kontekstu użytkownika pozostałym komponentom i 
widokom. Drugi natomiast to pasek nawigacji zawierający odnośniki do pozostałych stron.
Zależnie od roli zalogowanego użytkownika wyświetla różne odnośniki.
Strona główna zawiera odniesienia do komponentu \textbf{ReadingList} odpowiedzialnego
za wyświetlanie listy odczytów oraz ich filtrowanie według daty.
Strona z ustawieniami natomiast używa komponentów \textbf{EmailConfig} zawierającego
ustawienia notyfikacji poprzez pocztę email oraz \textbf{ValidationRule} 
zawierającą ustawienia walidacji odczytów. Komponenty oraz strony, które
wymagają połączenia z aplikacją serwerową lub wykonują sprawdzanie danych
dodatkowo używają komponent toastów służący do wyświetlania informacji w okienku modalnym.

\subsection{Implementacja wybranych funkcjonalności}
Aby użytkownik nie musiał za każdym wejściem na stronę ponownie logować się
zastosowano przechowywanie tokena w pamięci lokalnej przeglądarki.
Gdy użytkownik ponownie odwiedza witrynę jeżeli był on wcześniej zalogowany
pobierany jest token z pamięci lokalnej, a następnie za jego pomocą pobierane
są jego dane. Na listingu \ref{lazy_token} przedstawiono ładowanie tokenu z pamięci
lokalnej, a \ref{load_user} przedstawia implementację wczytywania szczegółów użytkownika
z serwera wraz z komponentem \textbf{UserContextProvider}.
\begin{lstlisting}[caption={Wczytywanie tokenu z pamięci lokalnej},label={lazy_token},captionpos=b]
lazy_static! {
    pub static ref TOKEN: RwLock<Option<String>> = {
        if let Ok(token) = LocalStorage::get(TOKEN_KEY) {
            RwLock::new(Some(token))
        } else {
            RwLock::new(None)
        }
    };
}
\end{lstlisting}
Po zamontowaniu komponent \textbf{UserContextProvider} sprawdza czy istnieje w pamięci token,
a następnie w przypadku jego istnienia pobiera szczegóły użytkownika z serwera.
Jeżeli zapytanie powiodło się są one umieszczane w pamięci w przeciwnym przypadku
token jest z niej usuwany.
\begin{lstlisting}[caption={Implementacja komponentu UserContextProvider},label={load_user},captionpos=b]
#[function_component(UserContextProvider)]
pub fn user_context_provider(props: &Props) -> Html {
    let user_ctx = use_state(|| None);
    let current_user = use_async(async move { user::current().await });

    {
        let current_user = current_user.clone();
        use_mount(move || {
            if get_token().is_some() {
                current_user.run();
            }
        });
    }

    {
        let user_ctx = user_ctx.clone();
        use_effect_with_deps(
            move |current_user| {
                if let Some(user) = &current_user.data {
                    user_ctx.set(Some(user.clone()))
                }

                if let Some(err) = &current_user.error {
                    match err {
                        crate::error::Error::Unauthorized(_) => {
                            user_ctx.set(None);
                            set_token(None);
                        }
                        _ => {}
                    }
                }

                || ()
            },
            current_user.clone(),
        )
    }

    html! {
        <ContextProvider<UseStateHandle<Option<UserInfo>>> context={user_ctx} children={props.children.clone()} />
    }
}
\end{lstlisting}

Ze względu na limitację frameworku Yew implementacja okienek modalnych było 
znacznie łatwiejsze z wykorzystaniem języka TypeScript. Poprzez wykorzystanie
technologii wasm-bindgen zostały wygenerowane połączenia między językami co pozwoliło
na wykorzystanie kodu TypeScript w komponentach. Kod odpowiedzialny za
definicję interfejsu został przedstawiony na listingu \ref{js:bindings}, a
ich implementacja na listingu \ref{js:impl}.
\begin{lstlisting}[caption={Interfejs dla funkcjonalnosci notyfikacji oraz WebSocket},label={js:bindings},captionpos=b]
#[wasm_bindgen(module = "/src/js/notifications.ts")]
extern "C" {
    #[wasm_bindgen]
    pub fn notify(title: &str, body: &str);
    #[wasm_bindgen]
    pub fn show_error(text: &str);
    #[wasm_bindgen]
    pub fn set_send_ping_interval(ws: &web_sys::WebSocket, interval: u32);
    #[wasm_bindgen]
    pub fn set_on_close(ws: &web_sys::WebSocket);
}
\end{lstlisting}
Funkcje zaimplementowane w języku TypeScript tworzą okienka modalne z podanym tytułem oraz
wiadomością wykorzystując do tego funkcjonalność biblioteki Bootstrap. Tworzony jest
kontener na wiadomości mający indeks 9999 co oznacza, że będzie wyświetlany wyżej
od reszty komponentów i nie będzie przez nie zasłonięty oraz nie będzie ingerował w ich
wygląd. Dodatkowo w języku TypeScript zostały zaimplementowane niektóre funkcjonalności
związane z wykorzystaniem technologii WebSocket, takie jak wysyłanie wiadomości z ustalonym
interwałem oraz rozłączanie połączenia przy wyłączeniu okienka zawierającego stronę.
\begin{lstlisting}[caption={Implementacja funkcjonalnosci notyfikacji oraz WebSocket},label={js:impl},captionpos=b]
export function notify(title: string, msg: string) {
    var toast = build_toast(title, msg);
    var toast_container = document.getElementById('toast-container');
    if (toast_container === null) {
        toast_container = document.createElement('div');
        toast_container.id = 'toast-container';
        toast_container.classList.add('position-fixed', 'bottom-0', 'end-0', 'p-3');
        toast_container.style.zIndex = '9999';
        document.body.appendChild(toast_container);
    }

    toast_container.appendChild(toast);
    var toast_obj = new bootstrap.Toast(toast);
    toast_obj.show();
}

export function show_error(text: string) {
    notify('Error', text);
}

export function set_send_ping_interval(ws: WebSocket, interval: number) {
    setInterval(() => {
        ws.send('ping');
    }, interval);
}

export function set_on_close(ws: WebSocket) {
    window.onclose = () => {
        ws.close();
    };
}

function build_toast(title: string, msg: string) {
    var toast = document.createElement('div');
    toast.classList.add('toast');
    toast.setAttribute('role', 'alert');
    toast.setAttribute('aria-live', 'assertive');
    toast.setAttribute('aria-atomic', 'true');
    toast.innerHTML = `
        <div class="toast-header">
            <strong class="me-auto">${title}</strong>
            <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
        <div class="toast-body">
            ${msg}
        </div>
    `;

    return toast;
}
\end{lstlisting}

Zależnie od tego czy użytkownik jest zalogowany może on otrzymywać notyfikacje o przekroczeniu
wartości danych parametrów odczytów. Zostało to wykonane poprzez wykorzystanie połączenia 
WebSocket z serwerem, który w takich przypadkach wysyła wiadomość w formie JSON z polem
\textbf{type} o wartości \textit{notification}. Jeżeli użytkownik jest zalogowany i aplikacja
otrzyma taką wiadomość wykorzystywana jest wcześniej zaprezentowana funkcjonalność okienek modalnych,
aby wyświetlić informację zawartą w polu \textbf{data} wiadomości otrzymanej z serwera.
Kod odpowiedzialny za tą funkcjonalność został przedstawiony na lisitingu \ref{show_notif}.
\begin{lstlisting}[caption={Implementacja wyświetlania powiadomień},label={show_notif},captionpos=b]
use_effect_with_deps(
    move |_user| {
        if let Some(notification_ws) = &*notification_ws.clone() {
            let on_message = Closure::<dyn FnMut(_)>::new(move |e: MessageEvent| {
                let data = e.data().as_string().unwrap();
                if let Ok(notification) = serde_json::from_str::<NotificationPayload>(&data) {
                    if notification.r#type.to_lowercase() == "notification" {
                        bindings::notify("New notification", &notification.data.join(" "));
                    }
                }
            });
            notification_ws.set_onmessage(Some(on_message.as_ref().unchecked_ref()));
            on_message.forget();
            set_send_ping_interval(notification_ws, 20000);
            set_on_close(notification_ws);
        }
        || ()
    },
    (*user).clone(),
);
\end{lstlisting}


\section{Urządzenie pomiarowe}
Do wykonywania pomiarów wykorzystany został mikrokontroler Raspberry Pi Pico W.
W celu uproszczenia tworzenia oprogramowania użyto nieoficjalnej implementacji
środowiska Arduino dla płytek z rodziny RP2040. Udostępnia ona prosty
w obsłudze poziom abstrakcji, który umożliwia na wykorzystanie głównych
możliwości mikrokontrolera takich jak odczyty z portów czy możliwość połączenia
z siecią bezprzewodową Wi-Fi. Możliwe jest dzięki temu również korzystanie z
wielu bibliotek stworzonych przez społeczność, które znacznie ułatwiają implementację.
Przykładem takiego modułu jest OneWire - biblioteka dodająca obsługę sensorów 
wykorzystujących jedną linię danych jako magistralę.
Jej wykorzystanie umożliwiło wykorzystanie jednej linii danych do połączenia wielu 
sensorów tej samej klasy.

W celu ułatwienia komunikacji z serwerem wykorzystana została zmodyfikowana wersja
generatora cpp-tiny znajdująca się w oprogramowaniu openapi-generator wykorzystując
wygenerowaną dokumentację OpenAPI 3.0. 
Ze względu na różnice w implementacji frameworku Arduino, aby uzyskać poprawnie 
wygenerowany kod zostały dokonane zmiany do plików mustache odpowiadających za składnię
generowanego kodu. W pliku Service.h.mustache, będącej nagłówkiem klasy odpowiadającej za komunikację z serwerem
oraz odpowiadającym serwisem, w celu usprawnionej obsługi nagłówków
HTTP oraz ich przechowywaniu do wykonania zapytania dodano zmienną przechowujące te nagłówki.
Podobnie, aby dostosować się do zmienionej logiki w pliku Service.cpp.mustache zmodyfikowane
zostało zapisywanie nagłówków - zamiast przechowywać je w kliencie HTTP, gdzie byłyby usuwane podczas
rozpoczęcia zapytania, przechowywane są we wcześniej stworzonej zmiennej, a następnie są one
wstrzykiwane klientowi zaraz po rozpoczęciu zapytania oraz przed jego wysłaniem.
Podobnie w przypadku pustych odpowiedzi wygenerowany kod nie był ich w stanie obsłużyć,
ze względu na implementację klienta HTTP, co kończyło się dostępem do niezmapowanej pamięci. 
Aby to rozwiązać w funkcji odpowiedzialnej 
za pobieranie odpowiedzi dodano dodatkowe zabezpieczenie w postaci sprawdzenia
długości odpowiedzi, jeżeli wynosi -1 odpowiedź jest o nieznanej długości i całość przepisywana jest
do bufora z wykorzystaniem potoku, w przypadku 0 odpowiedź jest pusta, a przy wartościach większych od
0 tworzony jest bufor o tej długości.

\subsection{Architektura aplikacji}
Aplikacja udostępnia abstrakcyjną klasę \textbf{Sensor} zawierającą metody wymagane do 
podstawowej obsługi sensorów. W projekcie umieszczone zostały implementacje tej klasy
dla dwóch typów sensorów \textbf{OneWire} oraz \textbf{DHT}. Pierwszy z nich wykorzystuje
sensory Dallas Temperature, aby uzyskiwać wyniki temperatur. DHT natomiast jest w stanie
obsłużyć dwa sensory DHT11 oraz DHT22 obydwa posiadające możliwość pomiarów temperatury oraz
wilgotności powietrza. Implementacja została przedstawiona na diagramie klas \ref{diagram:sensors}.
\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{sensor_class}
  \caption{Diagram klas sensorów oraz odczytów}
  \label{diagram:sensors}
\end{figure}


\subsection{Implementacja wybranych funkcjonalności}
Podczas startu urządzenie łączy się z siecią Wi-Fi wcześniej zdefiniowaną przez użytkownika.
Jeżeli połączenie powiodło się następuje synchronizacja czasu z zewnętrznym serwerem NTP.
Zapewnia to spójność znaków czasu między urządzeniami w systemie, co wykorzystywane jest
przy procesowaniu pomiarów. Następnym krokiem jest inicjalizacja połączenia z serwerem.
Urządzenie najpierw próbuje przejść proces uwierzytelniania dostarczonym przez użytkownika
hasłem, jeżeli jest to pierwszy raz kiedy dane urządzenie łączy się z systemem tworzone jest
jemu nieaktywne konto, które następnie musi zostać zaakceptowane przez administratora.
Jeżeli wcześniejszy proces przebiegł z powodzeniem urządzenie kontynuuje do połączenia
z odpowiednim kanałem WebSocket po czym przechodzi do stanu normalnej operacji.
Aby zapewnić synchronizację z serwerem oraz dostęp do statusu połączenia wykorzystano
technologię WebSocket. Kod inicjalizacji połączenia został zaprezentowany na lisitingu
\ref{sconn:init}.
\begin{lstlisting}[language={C++},caption={Utworzenie konta i połączenie z serwerem},label={sconn:init},captionpos=b]
void init_server_connection() {
  Serial.println("Setup api");
  const char *mac = WiFi.macAddress().c_str();
  Tiny::Authenticate authPayload;
  authPayload.setUsername(mac);
  authPayload.setPassword(PASSWD);
  auto response = authApi.apiAuthAuthenticatePost(authPayload);
  if (response.code != 200) {
    Serial.println("Device not registered. Registering...");
    Tiny::RegisterDevice registerDevicePayload;
    registerDevicePayload.setIdentifier(authPayload.getUsername());
    registerDevicePayload.setUsername(authPayload.getUsername());
    registerDevicePayload.setPassword(PASSWD);
    auto response = authApi.apiAuthRegisterDevicePost(registerDevicePayload);
    if (response.code != 200) {
      Serial.printf("Error: %d\r\n", response.code);
      return;
    }

    auto response2 = authApi.apiAuthAuthenticatePost(authPayload);
    if (response2.code != 200) {
      Serial.printf("Error: %d\r\n", response2.code);
      return;
    }

    token = response2.obj.getToken();
  } else {
    token = response.obj.getToken();
  }

  Serial.println("Setup websocket");
  std::string wsPath = BASE_WS_PATH + token;
  webSocket.begin(API_HOST, HOST_PORT, wsPath.c_str(), "");
  webSocket.onEvent(onEvent);
  webSocket.setReconnectInterval(5000);
}
\end{lstlisting}
Urządzenie łączy się z odpowiednim gniazdem, a następnie co 30
sekund wysyła wiadomość z zawartością "ping" i oczekuje na odpowiedź "pong" od serwera.
Jeżeli nie otrzyma takiej wiadomości uznaje, że połączenie zostało zerwane, więc zamyka je
i po upływie 5 sekund próbuje utworzyć ponowną komunikację. Dzieje się to aż do momentu przywrócenia
połączenia po czym urządzenie powraca do normalnego trybu operacji odczytywania oraz
przesyłania danych z sensorów.

Urządzenie pomiarowe, podczas normalnej operacji, dokonuje pomiarów z podłączonych sensorów, 
a następnie przetwarza je i w odpowiednim formacie wysyła na serwer. Odbywa się to poprzez
wykorzystanie metody POST jednego z kontrolerów. Dane pomiaru zawierają takie informacje jak
data i czas wykonania, wartość, jednostka oraz typ pomiaru. Do autoryzacji tego zapytania
wykorzystywany jest wcześniej wygenerowany token JWT. Następnie urządzenie odczekuje wcześniej
skonfigurowaną ilość czasu przed następnym pomiarem. Jest ona obliczana jako różnica czasu, który
został spędzony na aktualnym przejściu, a ustalonym przez użytkownika okresem. Jeżeli jest ona
większa od zera urządzenie wyczekuje wyliczony przedział czasu, a następnie kontynuuje pracę.
Implementacja tego procesu została zaprezentowana na listingu \ref{sensor:loop}.
\begin{lstlisting}[language={C++},caption={Główna pętla urządzenia pomiarowego},label={sensor:loop},captionpos=b]
static auto end = 0;
static auto diff = 0;
void loop() {
  while (!webSocket.isConnected()) {
    webSocket.loop();
  }

  auto begin = millis();
  webSocket.loop();

  if (last_ping > ping_interval) {
    if (webSocket.isConnected())
      webSocket.sendTXT("ping");
    last_ping = 0;
  }

  if (diff >= send_interval) {
    diff = 0;
    std::vector<Reading> readings;
    for (auto sensor : sensors) {
      auto sensorReadings = sensor->read();
      readings.insert(readings.end(), sensorReadings.begin(),
                      sensorReadings.end());
    }

    auto body = convert(readings);
    auto auth = "Bearer " + token;
    readingApi.addHeader("Authorization", auth);
    auto response = readingApi.apiReadingCreateReadingsPost(body);
  }

  end = millis();
  last_ping += end - begin;
  diff += end - begin;
}
\end{lstlisting}

Do wykonywania pomiarów temperatur wykorzystano sensor DS1820B20. To urządzenie
wykorzystuje pojedyncze połączenie z kontrolerem umożliwiające na łączność
z wieloma sensorami na jednej linii danych. Ta funkcjonalność została wykorzystana
w implementacji i wartości pobierane są ze wszystkich sensorów podłączonych do tej
linii. Implementacja pobierania danych z sensorów została zaprezentowana na listingu 
\ref{onewire:impl}.
\begin{lstlisting}[language={C++},caption={Implementacja systemu OneWire},label={onewire:impl},captionpos=b]
std::vector<Reading> OneWireSensor::read() {
  std::vector<Reading> readings;
  sensors.requestTemperatures();
  uint8_t deviceCount = sensors.getDeviceCount();
  float value = 0;
  for (uint8_t i = 0; i < deviceCount; i++) {
    DeviceAddress deviceAddress;
    if (sensors.getAddress(deviceAddress, i)) {
      std::stringstream stream;
      for (int i = 0; i < 8; ++i) {
        stream << std::setfill('0') << std::setw(2) << std::hex
               << (uint)deviceAddress[i];
      }
      float temp = sensors.getTempC(deviceAddress);
      value += temp;

      auto now = time(nullptr);
      struct tm timeinfo;
      gmtime_r(&now, &timeinfo);
      char buf[sizeof("2011-10-08T07:07:09Z")];
      strftime(buf, sizeof(buf), "%FT%TZ", &timeinfo);
      readings.push_back(Reading{temp, "C", "temperature", stream.str(), buf});
    }
  }

  return readings;
}
\end{lstlisting}
